# ---------经过进一步研究，发现可对*Screen.kt作最小侵入式修改，即可解决加载速度提升和焦点左漂移的问题---------
# ---------在旧方案基础上修改得到python代码如下---------
import sys
import re

def process_kt_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    # 第一部分：删除指定的代码块
    lines_to_delete = []
    for i, line in enumerate(lines):
        line_content = line.strip()
        # 1. 删除shouldLoadMore函数
        if "val shouldLoadMore by remember {" in line_content:
            # 找到这个函数的结束位置
            j = i
            brace_count = 0
            in_braces = False
            while j < len(lines):
                if "{" in lines[j]:
                    brace_count += 1
                    in_braces = True
                if "}" in lines[j]:
                    brace_count -= 1
                if in_braces and brace_count == 0:
                    # 删除从i到j的所有行
                    for k in range(i, j + 1):
                        if k not in lines_to_delete:
                            lines_to_delete.append(k)
                    break
                j += 1
        
        # 2. 删除LaunchedEffect函数
        if "LaunchedEffect(shouldLoadMore) {" in line_content:
            j = i
            brace_count = 0
            in_braces = False
            while j < len(lines):
                if "{" in lines[j]:
                    brace_count += 1
                    in_braces = True
                if "}" in lines[j]:
                    brace_count -= 1
                if in_braces and brace_count == 0:
                    for k in range(i, j + 1):
                        if k not in lines_to_delete:
                            lines_to_delete.append(k)
                    break
                j += 1
    # 删除所有标记的行（从后往前删除，避免索引问题）
    lines_to_delete.sort(reverse=True)
    for idx in lines_to_delete:
        if idx < len(lines):
            del lines[idx]
    
    # 第二部分：插入新的代码
    new_lines = []
    i = 0
    while i < len(lines):
        line = lines[i]
        new_lines.append(line)
        
        # 1. 在import org.koin.androidx.compose.koinViewModel后插入import kotlinx.coroutines.delay
        if "import org.koin.androidx.compose.koinViewModel" in line.strip():
            new_lines.append("import kotlinx.coroutines.delay\n")
        
        i += 1
    
    # 第三部分：在showTip语句后插入LaunchedEffect代码块
    # 重新处理new_lines，因为之前已经在其中插入了import
    temp_lines = []
    i = 0
    while i < len(new_lines):
        line = new_lines[i]
        temp_lines.append(line)
        
        # 查找val showTip by remember语句
        if "val showTip by remember {" in line.strip():
            # 找到这个多行语句的结束位置
            brace_count = 0
            found_start = False
            
            # 首先找到语句的开始大括号
            for char in line:
                if char == '{':
                    brace_count += 1
                    found_start = True
            
            # 继续查找直到所有大括号匹配完成
            j = i
            while j < len(new_lines) and brace_count > 0:
                if j != i:  # 第一行已经处理过了
                    temp_lines.append(new_lines[j])
                    # 统计这一行中的大括号
                    for char in new_lines[j]:
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                j += 1
                
            # 更新i到语句的结束位置
            i = j - 1  # 因为循环末尾会i+=1
            
            # 在showTip语句结束后插入LaunchedEffect代码
            if brace_count == 0:  # 确保括号匹配完成
                launcher_code = """    LaunchedEffect(lazyGridState, dynamicViewModel) {
        while (true) {
            delay(1L)
            val listSize = dynamicViewModel.dynamicVideoList.size
            if (listSize == 0) continue
            val lastVisibleIndex = lazyGridState.layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: -1
            if (lastVisibleIndex >= listSize - 24) {
                scope.launch(Dispatchers.IO) {
                    dynamicViewModel.loadMoreVideo()
                }
            }
        }
    }
"""
                # 检查下一行是否为空行，如果不是则添加空行
                if i + 1 < len(new_lines) and new_lines[i + 1].strip() != "":
                    temp_lines.append("\n")
                temp_lines.append(launcher_code)
        
        i += 1
    
    # 如果temp_lines不为空，使用它作为最终结果
    if temp_lines:
        new_lines = temp_lines
    
    # 写入文件
    with open(filename, 'w', encoding='utf-8') as f:
        f.writelines(new_lines)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python script.py <filename>")
        sys.exit(1)
    
    filename = sys.argv[1]
    try:
        process_kt_file(filename)
        print(f"Successfully processed {filename}")
    except Exception as e:
        print(f"Error processing file: {e}")
        sys.exit(1)

# ---------以下为旧方案的提示词---------
请写一个python程序，在ci流程的sh脚本中调用，不用说调用方法，用户很清楚。
该python文件用来处理一个.kt文件，传入参数为文件名，实现如下功能：
首先删除部分内容：
1、删除以下4个函数所在行的全部内容
var currentFocusedIndex by remember { mutableIntStateOf(-1) }
和
    val shouldLoadMore by remember {
        derivedStateOf { dynamicViewModel.dynamicVideoList.isNotEmpty() && currentFocusedIndex + 12 > dynamicViewModel.dynamicVideoList.size }
    }
和
    val showTip by remember {
        derivedStateOf { dynamicViewModel.dynamicVideoList.isNotEmpty() && currentFocusedIndex >= 0 }
    }
和
    LaunchedEffect(shouldLoadMore) {
        if (shouldLoadMore) {
            scope.launch(Dispatchers.IO) {
                dynamicViewModel.loadMoreVideo()
            }
        }
    }
2、删除以下3条语句所在行的全部内容：
        if (showTip) {
            Text(
                modifier = Modifier.fillMaxWidth().offset(x = (-20).dp, y = (-8).dp),
                text = stringResource(R.string.entry_follow_screen),
                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),
                fontSize = 12.sp,
                textAlign = TextAlign.End
            )
        }
和
                    .onFocusChanged{
                        if (!it.isFocused) {
                            currentFocusedIndex = -1
                        }
                    }
和
                        onFocus = { currentFocusedIndex = index }

做完上面删除操作后，再作如下插入：
1、在
import org.koin.androidx.compose.koinViewModel
所在行的后一行插入
import kotlinx.coroutines.delay
2、在
    val scope = rememberCoroutineScope()
所在行的后一行插入
    LaunchedEffect(lazyGridState, dynamicViewModel) {
        while (true) {
            delay(1L)
            val listSize = dynamicViewModel.dynamicVideoList.size
            if (listSize == 0) continue
            val lastVisibleIndex = lazyGridState.layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: -1
            if (lastVisibleIndex >= listSize - 24) {
                scope.launch(Dispatchers.IO) {
                    dynamicViewModel.loadMoreVideo()
                }
            }
        }
    }
3、在
                    .onPreviewKeyEvent {
所在行的前一行插入
                    .onFocusChanged {}
4、在
                        data = remember(item.aid) {
所在行的后一行插入
                            val playValue: Long? = if (item.play != null && item.play != -1L) {
                                item.play
                            } else {
                                null
                            }
                            val danmakuValue: Int? = if (item.danmaku != null) {
                                val danmakuLong = item.danmaku
                                if (danmakuLong >= Int.MIN_VALUE && danmakuLong <= Int.MAX_VALUE) {
                                    val danmakuInt = danmakuLong.toInt()
                                    if (danmakuInt != -1) danmakuInt else null
                                } else {
                                    null
                                }
                            } else {
                                null
                            }
5、在
                        onLongClick = {onLongClickVideo(item) },
所在行的后一行插入
                        onFocus = {}


# ---------使用该提示词通过ds得到python代码如下，经验证，符合提示要求---------
import sys
import re

def process_kt_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    # 第一部分：删除指定的代码块
    lines_to_delete = []
    for i, line in enumerate(lines):
        line_content = line.strip()
        # 删除第一个函数
        if "var currentFocusedIndex by remember { mutableIntStateOf(-1) }" in line_content:
            lines_to_delete.append(i)
        
        # 删除第二个函数（可能跨行）
        if "val shouldLoadMore by remember {" in line_content:
            # 找到这个函数的结束位置
            j = i
            brace_count = 0
            in_braces = False
            while j < len(lines):
                if "{" in lines[j]:
                    brace_count += 1
                    in_braces = True
                if "}" in lines[j]:
                    brace_count -= 1
                if in_braces and brace_count == 0:
                    # 删除从i到j的所有行
                    for k in range(i, j + 1):
                        if k not in lines_to_delete:
                            lines_to_delete.append(k)
                    break
                j += 1
        
        # 删除第三个函数
        if "val showTip by remember {" in line_content:
            j = i
            brace_count = 0
            in_braces = False
            while j < len(lines):
                if "{" in lines[j]:
                    brace_count += 1
                    in_braces = True
                if "}" in lines[j]:
                    brace_count -= 1
                if in_braces and brace_count == 0:
                    for k in range(i, j + 1):
                        if k not in lines_to_delete:
                            lines_to_delete.append(k)
                    break
                j += 1
        
        # 删除第四个函数
        if "LaunchedEffect(shouldLoadMore) {" in line_content:
            j = i
            brace_count = 0
            in_braces = False
            while j < len(lines):
                if "{" in lines[j]:
                    brace_count += 1
                    in_braces = True
                if "}" in lines[j]:
                    brace_count -= 1
                if in_braces and brace_count == 0:
                    for k in range(i, j + 1):
                        if k not in lines_to_delete:
                            lines_to_delete.append(k)
                    break
                j += 1
        
        # 删除第一个语句块（if (showTip) { ... }）
        if "if (showTip) {" in line_content:
            j = i
            brace_count = 0
            in_braces = False
            while j < len(lines):
                if "{" in lines[j]:
                    brace_count += 1
                    in_braces = True
                if "}" in lines[j]:
                    brace_count -= 1
                if in_braces and brace_count == 0:
                    for k in range(i, j + 1):
                        if k not in lines_to_delete:
                            lines_to_delete.append(k)
                    break
                j += 1
        
        # 删除第二个语句块（.onFocusChanged{ ... }）
        if ".onFocusChanged{" in line_content or ".onFocusChanged{" in line:
            j = i
            brace_count = 0
            in_braces = False
            while j < len(lines):
                if "{" in lines[j]:
                    brace_count += 1
                    in_braces = True
                if "}" in lines[j]:
                    brace_count -= 1
                if in_braces and brace_count == 0:
                    for k in range(i, j + 1):
                        if k not in lines_to_delete:
                            lines_to_delete.append(k)
                    break
                j += 1
        
        # 删除第三个语句块（onFocus = { currentFocusedIndex = index }）
        if "onFocus = { currentFocusedIndex = index }" in line_content:
            lines_to_delete.append(i)
    
    # 删除所有标记的行（从后往前删除，避免索引问题）
    lines_to_delete.sort(reverse=True)
    for idx in lines_to_delete:
        if idx < len(lines):
            del lines[idx]
    
    # 第二部分：插入新的代码
    new_lines = []
    i = 0
    while i < len(lines):
        line = lines[i]
        new_lines.append(line)
        
        # 1. 在import org.koin.androidx.compose.koinViewModel后插入import kotlinx.coroutines.delay
        if "import org.koin.androidx.compose.koinViewModel" in line.strip():
            new_lines.append("import kotlinx.coroutines.delay\n")
        
        # 2. 在val scope = rememberCoroutineScope()后插入LaunchedEffect代码块
        if "val scope = rememberCoroutineScope()" in line.strip():
            launcher_code = """    LaunchedEffect(lazyGridState, dynamicViewModel) {
        while (true) {
            delay(1L)
            val listSize = dynamicViewModel.dynamicVideoList.size
            if (listSize == 0) continue
            val lastVisibleIndex = lazyGridState.layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: -1
            if (lastVisibleIndex >= listSize - 24) {
                scope.launch(Dispatchers.IO) {
                    dynamicViewModel.loadMoreVideo()
                }
            }
        }
    }
"""
            # 检查下一行是否为空行，如果不是则添加空行
            if i + 1 < len(lines) and lines[i + 1].strip() != "":
                new_lines.append("\n")
            new_lines.append(launcher_code)
        
        # 3. 在.onPreviewKeyEvent {前一行插入.onFocusChanged {}
        if ".onPreviewKeyEvent {" in line.strip() and i > 0:
            # 在前一行插入
            new_lines.insert(-1, "                    .onFocusChanged {}\n")
        
        # 4. 在data = remember(item.aid) {后一行插入变量声明代码块
        if "data = remember(item.aid) {" in line.strip() and i + 1 < len(lines):
            data_code = """                            val playValue: Long? = if (item.play != null && item.play != -1L) {
                                item.play
                            } else {
                                null
                            }
                            val danmakuValue: Int? = if (item.danmaku != null) {
                                val danmakuLong = item.danmaku
                                if (danmakuLong >= Int.MIN_VALUE && danmakuLong <= Int.MAX_VALUE) {
                                    val danmakuInt = danmakuLong.toInt()
                                    if (danmakuInt != -1) danmakuInt else null
                                } else {
                                    null
                                }
                            } else {
                                null
                            }
"""
            # 插入到当前行之后
            new_lines.append(data_code)
        
        # 5. 在onLongClick = {onLongClickVideo(item) },后一行插入onFocus = {}
        if "onLongClick = {onLongClickVideo(item) }," in line.strip() and i + 1 < len(lines):
            new_lines.append("                        onFocus = {}\n")
        
        i += 1
    
    # 写入文件
    with open(filename, 'w', encoding='utf-8') as f:
        f.writelines(new_lines)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python script.py <filename>")
        sys.exit(1)
    
    filename = sys.argv[1]
    try:
        process_kt_file(filename)
        print(f"Successfully processed {filename}")
    except Exception as e:
        print(f"Error processing file: {e}")
        sys.exit(1)
